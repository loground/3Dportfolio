/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: abhie18 (https://sketchfab.com/abhie18)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/hearthstone-card-c16dd61e5bd14ac893be475fd8101c24
Title: Hearthstone Card
*/

import React, { useState, useEffect, useMemo } from 'react';
import { Float, useGLTF } from '@react-three/drei';
import { useTexture } from '@react-three/drei';
import * as THREE from 'three';
import { useSpring, a } from '@react-spring/three';
import { useBrainScene } from '../Context';

export function HScard({ textureUrl, position, rotation, index }) {
  const { nodes, materials } = useGLTF('/3d/newPosHS.glb');
  const texture = useTexture(textureUrl);
  const [hovered, setHovered] = useState(false);

  const { selectedCard, setSelectedCard } = useBrainScene();
  const isSelected = selectedCard === index;

  const SELECTED_POSITION = [-6, 1, -3];
  const UNSELECTED_POSITION = [0, -10, 3];
  const SELECTED_ROTATION = [rotation[0] - 0.3, rotation[1], rotation[2] - 0.1];

  const { animatedPosition, animatedRotation } = useSpring({
    delay: isSelected && hovered && 1200,

    animatedPosition:
      selectedCard === null
        ? hovered
          ? [position[0], position[1] + 1.5, position[2] + 1]
          : position
        : isSelected
          ? SELECTED_POSITION
          : UNSELECTED_POSITION,

    animatedRotation: hovered
      ? [
          SELECTED_ROTATION[0] + (isSelected ? 0.2 : 0),
          SELECTED_ROTATION[1] + Math.PI * 2,
          SELECTED_ROTATION[2] + (isSelected ? 0.1 : 0),
        ]
      : isSelected
        ? SELECTED_ROTATION
        : rotation,

    config: { mass: 5, tension: 10, friction: 10 },
  });

  useEffect(() => {
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.offset.set(0.5, 0.5);
    texture.repeat.set(0.02, 0.013);
    texture.colorSpace = THREE.SRGBColorSpace;

    texture.needsUpdate = true;
  }, [texture]);

  const material = useMemo(() => {
    return new THREE.MeshStandardMaterial({
      map: texture,
    });
  }, [texture]);

  const shape = useMemo(() => {
    const width = 46;
    const height = 76;
    const radius = 10;
    const s = new THREE.Shape();
    s.moveTo(-width / 2 + radius, -height / 2);
    s.lineTo(width / 2 - radius, -height / 2);
    s.quadraticCurveTo(width / 2, -height / 2, width / 2, -height / 2 + radius);
    s.lineTo(width / 2, height / 2 - radius);
    s.quadraticCurveTo(width / 2, height / 2, width / 2 - radius, height / 2);
    s.lineTo(-width / 2 + radius, height / 2);
    s.quadraticCurveTo(-width / 2, height / 2, -width / 2, height / 2 - radius);
    s.lineTo(-width / 2, -height / 2 + radius);
    s.quadraticCurveTo(-width / 2, -height / 2, -width / 2 + radius, -height / 2);
    return s;
  }, []);

  const geometry = useMemo(
    () => new THREE.ExtrudeGeometry(shape, { depth: 0, bevelEnabled: false }),
    [shape],
  );

  return (
    <Float speed={0.3} rotationIntensity={0.5} floatIntensity={3}>
      <a.group
        position={animatedPosition}
        rotation={animatedRotation}
        scale={0.004}
        onClick={() => {
          setSelectedCard(isSelected ? null : index);
        }}
        onPointerOver={() => setHovered(true)}
        onPointerOut={() => setHovered(false)}>
        <mesh
          geometry={geometry}
          position={[0, -30, -15]}
          rotation={[0.001, Math.PI, 0]}
          scale={13}>
          <primitive object={material} transparent attach="material" />
        </mesh>
        <group>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.back_back_0.geometry}
            material={materials.back}
            position={[0, 0, -1.375]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Connect_ring_0.geometry}
            material={materials.ring}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.nails_nails_0.geometry}
            material={materials.nails}
            position={[0, 0, 7.871]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Polygon_Mat_0.geometry}
            material={materials.material}
            position={[0, 0, 17.683]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Polygon_1_Mat_0.geometry}
            material={materials.material}
            position={[0, 0, 17.683]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.sphere_Sphere_0.geometry}
            material={materials.Sphere}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.spikes_shade_glow_0.geometry}
            material={materials.shade_glow}
          />
        </group>
      </a.group>
    </Float>
  );
}

useGLTF.preload('/3d/newPosHS.glb');
